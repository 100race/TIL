# 브라우저 렌더링
  ## 브라우저 렌더링이란?
  브라우저의 핵심 기능은 사용자가 원하는 페이지를 서버에 요청(request)하고 응답(response)받아 브라우저에 표시하는것. 사용자가 사이트 접속시 서버로부터 HTML,CSS,JavaScript,Image파일 등을 받는다.
  ![브라우저렌더링과정](https://user-images.githubusercontent.com/46726709/108535478-ba7e8900-731e-11eb-8685-147bb5ba4920.png)
  
  1. DOM tree생성 <br>
    HTML 코드들을 HTML파서가 파싱하여 메모리 상에 DOM객체로 이루어진 DOM 트리를 생성한다.
  2. style 규칙 생성 <br>
    HTML,CSS 파일 안의 코드들을 CSS 파서가 파싱하여 메모리 상에 스타일 규칙 CSSOM 트리를 생성한다.
  3. render tree (렌더트리) 생성 <br>
    생성한 DOM트리와 CSSOM트리를 바탕으로 브라우저 화면에 노출되어야하는 노드들에 대한 정보인 렌더 트리를 생성한다. 이 때 <head>태그나 display 속성이 none 인 태그들 등등 눈에 보이지 않는 태그는
    렌더트리를 생성 시 제외한다. 진짜 화면에 보여질 것들만 추리는 과정.
  4. 레이아웃 (리플로우) <br>
    렌더 트리의 각 노드들이 화면의 어느 위치에 어떤 크기로 배치되어야 하는지에대한 정보를 계산한다.
  5. 페인트 (리페인트) <br>
    렌더 트리의 각 노드들을 실제로 브라우저 화면에 그리는 display 단계.
  
  ![브라우저동작원리](https://user-images.githubusercontent.com/46726709/108536741-20b7db80-7320-11eb-937f-e2e7792e1bf4.png)
  
  ## JavaScript (자바스크립트) 동작
   자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. 
   1. HTML파서가 <script>를 만나면 DOM생성 프로세스를 중단하고 자바스크립트 엔진에 제어 권한을 넘긴다.
   2. 자바스크립트 엔진은 <script>태그 내의 js코드와 src어트리뷰트에 정의된 js파일을 로드하고 파싱하여 실행.
   3. 자바스크립트 실행이 완료되고 HTML파서로 제어 권한을 넘겨 브라우저가 중지된 시점부터 DOM 생성 재개.
  
  ## script 태그 위치의 중요성
  이처럼 브라우저는 동기(Synchronous)적으로 HTML, CSS, Javascript을 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 
  따라서 script 태그의 위치는 중요한 의미를 갖는다. body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어이다. 그 이유는 아래와 같다.
  - HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
  - DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다.
  
  ## Reflow(리플로우), Repaint(리페인트)
  HTML을 읽는 과정에 스크립트를 만나면 중단 시점이 생기고 그만큼 Display에 표시되는 것이 지연된다.
  DOM 트리가 생성되기전에 자바스크립트가 생성되지도 않은 DOM의 조작을 시도할 수 있다. 
  문서를 DOM 트리로 표현한 덕분에, JavaScript와 같은 스크립트 언어로 문서의 각 요소를 조작할 수 있게 되었다. 
  그런데 사실 스크립트 언어로 특정 DOM 노드에 해당하는 객체에 접근하여 CRUD 작업을 수행하는 것은 가벼운 연산이 아니다.
  하나의 DOM 노드가 조작될 때마다 DOM 트리와 스타일 규칙들이 수정되므로 렌더 트리를 다시 생성해야 하고, 
  그 렌더 트리를 대상으로 레이아웃 단계와 페인트 단계를 다시 거쳐야 하기 때문이다. 레이아웃 단계를 다시 거치는 것을 
  리플로우(Reflow)라고 하며, 페인트 단계를 다시 거치는 것을 리페인트(Repaint)라고 한다. 그런데 레이아웃 단계와 페인트 
  단계는 꽤나 오버헤드가 큰 작업이다. 물론 레이아웃에 영향을 미치지 않는 선에서 CRUD 작업을 수행한다면(예를 들어 색상만
  바꾼다든지) 리플로우는 수행하지 않을 것이지만 여전히 리페인트는 수행한다. 이러한 문제점을 해결하기 위해 등장한 것이 바로
  Virtual DOM이다.
  
  ## Virtual DOM (React의 등장)
  실제 DOM을 모방하는 형태로 메모리 상에만 존재하는 가상의 DOM. 
   > DOM노드를 조작하는 작업은 브라우저의 성능 저하를 유발한다. 이 문제점을 해결하기 위해 등장한 것이 Virtual DOM.
  실제 화면에 렌더링 하는 과정을 거치지 않고 메모리 상에서만 그려지는 DOM이기 때문에 오버헤드가 적다. Virtual DOM을 활용해
  문서의 요소를 효율적으로 동적 제어를 할 수 있다. 이를 이용한 대표적인 Javascript 라이브러리가 React
  
  React는 문서의 특정 부분이 리렌더링 되어야 할 때 그 부분에 해당하는 Virtual DOM 트리를 메모리에 새로 생성한다. 그
  리고 이전에 존재하던 Virtual DOM 트리와 O(n)의 휴리스틱 알고리즘으로 비교하여 차이점을 파악한다. 그리고 그 차이점들을
  하나로 모아서 실제 DOM에게 전달해준다. 이로 인해 실제 DOM의 리렌더링 연산(리플로우, 리페인트)은 단 한 번만 일어나게 되어,
  큰 성능의 이득을 얻게 된다(Batch Update). 물론 React는 JavaScript 라이브러리이기 때문에, React가 할 수 있는 건 바닐라 
  JavaScript로도 할 수 있다. 즉 바닐라 JavaScript로 실제 DOM을 조작할 때도 DOM fragment를 잘 활용하면 여러 차이점들을 
  하나로 모아서 딱 한 번의 리렌더링 연산만 수행하는 것이 가능하다. 그러나 이를 위해서는 매번 어떤 DOM 노드가 변경되어야 하고 
  어떤 DOM 노드는 변경될 필요가 없는지 등을 파악할 수 있어야 하고, 이는 복잡한 과정이기 때문에 실수가 발생할 가능성도 커진다. 
  React의 Virtual DOM은 이러한 복잡한 과정들을 자동화 및 추상화해준다는 점에서 의미가 있다고 할 수 있다.







### 참조
[브라우저 동작 원리](https://poiemaweb.com/js-browser)<br>
[브라우저 렌더링의 원리](https://velog.io/@ksh4820/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9B%90%EB%A6%AC)<br>
[virtualDOM이란?](https://it-eldorado.tistory.com/87)<br>
